# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------

from typing import List, Any, Union, TYPE_CHECKING, overload, Optional, TypeVar
from urllib.parse import urlparse

from azure.core.pipeline import PipelineRequest
from azure.core.pipeline.transport import HttpResponse as LegacyHttpResponse, HttpRequest as LegacyHttpRequest
from azure.core.rest import HttpResponse, HttpRequest
from azure.core.pipeline.policies import SansIOHTTPPolicy, AzureKeyCredentialPolicy

from ._client import OpenAIClient as GeneratedOpenAIClient
from .operations._patch import Stream


if TYPE_CHECKING:
    from azure.core.credentials import TokenCredential

HTTPResponseType = TypeVar("HTTPResponseType", HttpResponse, LegacyHttpResponse)
HTTPRequestType = TypeVar("HTTPRequestType", HttpRequest, LegacyHttpRequest)


class KeyCredential:
    """Credential type used for authenticating with API key to the Azure OpenAI or OpenAI service.
    It provides the ability to update the key without creating a new client.

    :param str key: The key used to authenticate to a service
    :raises: TypeError
    """

    def __init__(self, key: str) -> None:
        if not isinstance(key, str):
            raise TypeError("key must be a string.")
        self._key = key

    @property
    def key(self) -> str:
        """The value of the configured key.

        :rtype: str
        :return: The value of the configured key.
        """
        return self._key

    def update(self, key: str) -> None:
        """Update the key.

        This can be used when you've regenerated your service key and want
        to update long-lived clients.

        :param str key: The key used to authenticate to a service
        :raises: ValueError or TypeError
        """
        if not key:
            raise ValueError("The key used for updating can not be None or empty")
        if not isinstance(key, str):
            raise TypeError("The key used for updating must be a string.")
        self._key = key


class URLRewritePolicy(SansIOHTTPPolicy[HTTPRequestType, HTTPResponseType]):
    def __init__(self, url: str) -> None:
        super().__init__()
        self.url = url

    def on_request(self, request: PipelineRequest[HTTPRequestType]) -> None:
        url_parsed = urlparse(request.http_request.url)
        if "deployments" in url_parsed.path:
            # remove openai/deployments/deployment_id from the path
            parts = url_parsed.path.split("/")
            path = "/".join(parts[parts.index("deployments")+2:])
            request.http_request.url = self.url + f"/{path}"
        elif "images" in url_parsed.path:
            # TODO should we support this? hacky to get working
            request.http_request.url = self.url + "/images/generations"
        else:
            # just strip the added /openai to the path
            parts = url_parsed.path.split("/")
            request.http_request.url = self.url + "/".join(parts[1:])


class OpenAIClient(GeneratedOpenAIClient):
    """OpenAIClient.

    :ivar completions: CompletionsOperations operations
    :vartype completions: azure.openai.operations.CompletionsOperations
    :ivar chat: ChatOperations operations
    :vartype chat: azure.openai.operations.ChatOperations
    :ivar embeddings: EmbeddingsOperations operations
    :vartype embeddings: azure.openai.operations.EmbeddingsOperations
    :ivar images: ImagesOperations operations
    :vartype images: azure.openai.operations.ImagesOperations
    :ivar audio: AudioOperations operations
    :vartype audio: azure.openai.operations.AudioOperations
    :param endpoint: Supported Cognitive Services endpoints (protocol and hostname, for example:
     https://westus.api.cognitive.microsoft.com). Required.
    :type endpoint: str
    :param credential: Credential needed for the client to connect to Azure. Is either a
     AzureKeyCredential type or a TokenCredential type. Required.
    :type credential: ~azure.openai.KeyCredential or
     ~azure.core.credentials.TokenCredential
    :keyword api_version: The API version to use for this operation. Default value is
     "2023-09-01-preview". Note that overriding this default value may result in unsupported
     behavior.
    :paramtype api_version: str
    """

    @overload
    def __init__(self, endpoint: str, credential: KeyCredential, **kwargs: Any) -> None:
        ...

    @overload
    def __init__(self, endpoint: str, credential: "TokenCredential", **kwargs: Any) -> None:
        ...

    @overload
    def __init__(self, *, openai_api_key: KeyCredential, **kwargs: Any) -> None:
        ...

    def __init__(self, *args, **kwargs: Any) -> None:
        if "openai_api_key" in kwargs:
            endpoint = "https://api.openai.com/v1"
            credential = kwargs.pop("openai_api_key")
            authentication_policy = AzureKeyCredentialPolicy(
                credential=credential,
                name="Authorization",
                prefix="Bearer",
            )
            kwargs.update(
                {
                    "authentication_policy": kwargs.pop("authentication_policy", None) or authentication_policy,
                    "per_call_policies": kwargs.pop("per_call_policies", None) or URLRewritePolicy(endpoint),
                }
            )
        else:
            positional = list(args)
            endpoint =  positional.pop(0) if positional else kwargs.pop("endpoint", None)
            credential =  positional.pop(0) if positional else kwargs.pop("credential", None)

            if isinstance(credential, KeyCredential):
                authentication_policy = AzureKeyCredentialPolicy(
                    credential=credential,
                    name="api-key",
                )
                kwargs.update(
                    {
                        "authentication_policy": kwargs.pop("authentication_policy", None) or authentication_policy,
                    }
                )
        super().__init__(endpoint=endpoint, credential=credential, **kwargs)


__all__: List[str] = ["OpenAIClient", "KeyCredential", "Stream"]

def patch_sdk():
    """Do not remove from this file.

    `patch_sdk` is a last resort escape hatch that allows you to do customizations
    you can't accomplish using the techniques described in
    https://aka.ms/azsdk/python/dpcodegen/python/customize
    """
